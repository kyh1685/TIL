### 상속 개념
- 부모 클래스의 멤버를 자식 클래스에게 물려주는 것이다.
- 이미 개발된 클래스를 재사용하기 떄문에 **코드의 중복을 줄여준다**.
- 부모 클래스를 수정하면 모든 자식 클래스도 수정되기 때문에 **유지보수 시간이 줄어든다.**
- 부모 클래스에서 **private를 갖는 멤버는 상속에서 제외**된다.
- 부모 클래스에 default를 갖는 멤버 또한 부모, 자식 클래스가 다른 패키지에 있다면 제외된다.
```java
class 자식클래스 extends 부모클래스{
	// 멤버
}
```

### 부모 생성자 호출
- 자식 객체를 생성하면 부모 객체가 먼저 생성이 되고 그 다음에 자식 객체가 생성된다.
- 부모 생성자는 자식 생성자 **맨 첫 줄에서 호출**된다.( super() : 부모의 기본 생성자를 호출한다.)
- super()가 생략되면 컴파일러가 자동으로 super()을 추가해주기 때문에 **부모의 기본 생성자가 존재해야 한다.**
- 부모 클래스의 기본 생성자가 없고 매개 변수가 있는 생성자만 있다면 **자식 생성자에서 super(매개값)을 명시적으로 호출**해야한다.

### 메소드 재정의

#### 메소드 재정의(@Override)
- 오버라이딩(Overriding)은 상속된 내용이 자식 클래스에 맞지 않을 경우, 자식 클래스에서 동일한 **메소드를 재정의**하는 것을 말한다.
- 오버라이딩 시 주의점
    - 부모와 동일한 리턴 타입, 메소드 이름, 매개 변수 리스트를 가져야 한다.
    - 접근 제한을 더 강하게 오버라이딩할 수는 없다. ex) 부모 메서드 public -> 자식 메서드 private(x)
    - 새로운 예외를 throw할 수 없다.
- 어노테이션을 생략할 수 있으나 어노테이션이 붙으면 컴파일러가 정확히 오버라이딩이 됐는지 확인해주기 때문에 실수를 줄일 수 있다.

#### 부모 메소드 호출(super)
- 자식 클래스에서 부모 클래스의 메소드를 오버라이드하면 부모 클래스의 메소드를 숨겨지고 오버라이딩된 자식 메소드만 사용된다. 이 때 오버라이딩이 안된 부모 메소드를 사용하고 싶으면 **super.부모 메소드()**를 해주면 된다.

### final 클래스와 final 메소드
- **final 클래스는** 최종적인 클래스이므로 **부모 클래스가 될 수 없다.**
- **final 메소드는** 최종적인 메소드이므로 **오버라이딩할 수 없다.**

### protected 접근 제한자
- 같은 패키지 내에 또는 다른 패키지여도 자식 클래스일 경우 접근을 허용한다.
- 단 new 연산자를 사용해서 생성자를 직접 호출할 수는 없고 자식 생성자에서 super().로 부모 생성자를 호출할 수 있다.

### 타입 변환과 다형성
- 다형성은 같은 타입이지만 실행 결과가 다양한 객체를 이용할 수 있는 성질을 말한다.
- **부모 타입에 모든 자식 객체라 대입**될 수 있다.

#### 자동 타입 변환(Promotion)
- 자동 타입 변환은 프로그램 실행 도중에 자동으로 타입 변환이 일어나는 것을 말한다.
```java
Tire t1 = new HankookTire();
Tire t2 - new kumhoTIre();
```
- 부모 타입으로 **자동 타입 변환된 이후에는 부모 클래스에 선언된 멤버만 접근**이 가능하다. 
- 메소드가 **자식 클래스에서 오버라이딩 되었다면 자식 클래스 메소드가 호출**된다.

#### 필드의 다형성
- 필드의 타입을 변경하지 않아도 어떤 객체를 이 필드에 저장하는지에 따라 실행 결과가 달라진다. 예를 들어 TV 객체가 있고 그것을 상속받은 삼성TV, 엘지TV가 있다고 하면 필드의 타입은 그대로 TV면서 안에 내용은 삼성이나 엘지로 쉽게 바꿀 수 있는 것이다. 둘 다 TV를 상속 받았기 때문에 어떤 것으로 바꿔도 문제가 없을 것이고 삼성TV가 powerOn() 기능을 더욱 향상시켜 오버라이딩 했을때 TV의 내용을 삼성TV로 변경하면 더 향상된 기능을 사용할 수 있다. 

#### 매개 변수의 다형성 
- 매개 변수의 타입이 클래스인 경우 해당 클래스의 객체뿐만 아니라 자식 객체까지도 매개값으로 사용할 수 있다.

#### 강제 타입 변환(Casting)
- 부모 타입을 자식 타입으로 변환하는 것을 말한다.
- 자식 타입이 부모 타입으로 자동 변환 후, 다시 자식 타입으로 변환할 떄 강제 타입 변환을 사용할 수 있다.

### 추상 클래스
- 객체를 직접 생성할 수 있는 **실체 클래스의 공통적인 특성만 추출해서 선언한 클래스를 추상 클래스**라고 한다.
- 추상 클래스와 실체 클래스는 상속관계를 가지고 있다. 부모 클래스가 추상 클래스, 자식 클래스가 실체 클래스이다.
- **추상 클래스는 객체를 직접 생성할 수 없다.**

#### 추상 클래스의 용도
- 실체 클래스들의 공통된 필드, 메소드의 이름 통일
- 실체 클래스 작성 시 시간 절약

#### 추상 클래스 선언
- 클래스 선언 시에 abstract를 붙이면 new 연산자를 이용해 객체를 만들지 못하고 상속을 통해 자식 클래스만 만들 수 있다.
```java
public abstract class 클래스{
	// 멤버
}
```
- 자식 객체가 생성될 때 super()를 호출해서 추상 클래스 객체를 생성하므로 **추상 클래스도 생성자가 있어야 한다.**

#### 추상 메소드와 오버라이딩
- 추상 메소드는 **추상 클래스에서만 선언**할 수 있다.
-** 메소드의 선언부만 있고 실행 내용인 중괄호가 없다.**
- 추상 클래스를 설계할 때 자식 클래스가 반드시 실행 내용을 채우도록 강요하고 싶은 메소드가 있을 경우 선언한다.
- 자식 메서드가 추상 메소드를 재정의하지 않으면 컴파일 에러가 발생한다.
