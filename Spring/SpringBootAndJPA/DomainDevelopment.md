# 회원, 상품 도메인 개발

_김영한 강사님의 실전! 스프링 부트와 JPA 활용1 - 웹 애플리케이션 개발 강의를 정리한 내용입니다._

~~애플리케이션 구현 준비, 회원 도메인, 상품 도메인 내용이 없어서 하나로 합침~~

## 애플리케이션 아키텍쳐
![](https://images.velog.io/images/3hee_11/post/2f40f361-5b72-4082-8b0a-0084fb800a44/image.png)

- controller, web : 웹 계층
- service : 비즈니스 로직, 트랜잭션 처리
- repository : JPA를 직접 사용하는 계층, 엔티티 매니저 사용
- domain : 엔티티가 모여 있는 계층, 모든 계층에서 사용

#### 기술
- @Repository : 스프링 빈으로 등록, JPA 예외를 스프링 기반 예외로 예외 변환
- @PersistenceContext : 엔티티 메니저(EntityManager) 주입
- @PersistenceUnit : 엔티티 메니터 팩토리(EntityManagerFactory) 주입
- @Transactional : 트랜잭션, 영속성 컨텍스트
  - readOnly=true : 데이터의 변경이 없는 읽기 전용 메서드에 사용, 영속성 컨텍스트를 플러시 하지 않으므로 성능 향상
  - 데이터베이스 드라이버가 지원하면 DB에서 성능 향상
- @SpringBootTest : 스프링 부트 띄우고 테스트(이게 없으면 @Autowired 다 실패)
- @Transactional(테스트에서 사용시) : 반복 가능한 테스트 지원, 각각의 테스트를 실행할 때마다 트랜잭션을 시작하고 테스트가 끝나면 트랜잭션을 강제로 롤백(이 어노테이션이 **테스트 케이스에서 사용될 때만 롤백**)

#### 테스트 케이스를 위한 설정
- 테스트는 케이스 격리된 환경에서 실행하고 끝나면 데이터를 초기화하는 것이 좋으므로 **메모리 DB를 사용**하자.
- 테스트 케이스를 위한 스프링 환경과 일반적으로 애플리케이션을 실행하는 환경은 보통 다르므로 설정 파일을 다르게 사용하자.
👉 test/resources 파일을 만들고 application.yml을 복사해서 넣기

### 상품 리포지토리
- save()
  - id가 없으면 신규로 보고 persist() 실행
  - id가 있으면 이미 DB에 저장된 엔티티를 수정한다고 보고 merge()를 실행

# 주문 도메인 개발
  
## 주문, 주문상품 엔티티 개발

### ✔ 주문 엔티티
- **생성 메서드(createOrder())** : 주문 엔티티를 생성할 때 사용한다. 주문 회원, 배송정보, 주문상품의 정보를 받아서 실제 주문 엔티티를 생성한다.
- **주문 취소(cancel())** : 주문 취소시 사용한다. 주문 상태를 취소로 변경하고 주문상품에 주문 취소를 알린다. 만약 이미 배송을 완료한 상품이면 주문을 취소하지 못하도록 예외를 발생시킨다.
- **전체 주문 가격 조회** : 주문 시 사용한 전체 주문 가격을 조회한다. 전체 주문 가격을 알려면 각각의 주문상품 가격을 알아야 한다. 로직을 보면 연관된 주문상품들의 가격을 조회해서 더한 값을 반환한다. (실무에서는 주로 주문에 전체 주문 가격 필드를 두고 역정규화 한다.)

### ✔ 주문상품 엔티티
- **생성 메서드(createOrderItem())** : 주문 상품, 가격, 수량 정보를 사용해서 주문상품 엔티티를 생성한다. 그리고 item.removeStock(count)를 호출해서 주문한 수량만큼 상품의 재고를 줄인다.
- **주문 취소(cancel())** : getItem().addStock(count)를 호출해서 취소한 주문 수량만큼 상품의 재고를 증가시킨다.
- **주문 가격 조회(getTotalPrice())** : 주문 가격에 수량을 곱한 값을 반환한다.

## 주문 리포지토리 개발
주문 리포지토리에는 주문 엔티티를 저장하고 검색하는 기능이 있다.  ~~findAll(OrderSearch orderSearch) 메서드는 뒷부분에 작성할 예정~~

## 주문 서비스 개발
주문 서비스는 주문 엔티티와 주문 상품 엔티티의 비즈니스 로직을 활용해서 주문, 주문 취소, 주문 내역 검색 기능을 제공한다.

- **주문(order())** : 주문하는 회원 식별자, 상품 식별자, 주문 수량 정보를 받아서 실제 주문 엔티티를 생성한 후 저장한다.
- **주문 취소(cancelOrder())** : 주문 식별자를 받아서 주문 엔티티를 조회한 후 주문 엔티티에 주문 취소를 요청한다.
- **주문 검색(findOrders())** : OrderSearch 라는 검색 조건을 가진 객체로 주문 엔티티를 검색한다. 

### 📌 참고 
> **[도메인 모델 패턴](http://martinfowler.com/eaaCatalog/domainModel.html)** : **엔티티가 비즈니스 로직을 가지고** 객체 지향의 특성을 활용하는 것
> **[트랜잭션 스크립트 패턴](http://martinfowler.com/eaaCatalog/transactionScript.html)** : 엔티티에는 비즈니스 로직이 거의 없고 **서비스 계층에서 대부분의 비즈니스 로직을 처리**하는 것

## 주문 검색 기능 개발

#### 🤔 JPA에서 동적 쿼리를 어떻게 해결해야 하는가?

- **JPQL로 처리** : JPQL 쿼리를 문자로 생성하기는 번거롭고, 실수로 인한 버그가 충분히 발생할 수 있다.

- **JPA Criteria로 처리** : JPA Criteria는 JPA 표준 스펙이지만 실무에서 사용하기에 너무 복잡하다.

📌 **해결방안** : Querydsl 사용!
